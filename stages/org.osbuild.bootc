#!/usr/bin/python3
"""
Deploy a bootc-enabled container

Run a bootc-enabled container image to install it to a filesystem tree.
"""
import json
import os
import subprocess
import sys

import osbuild.api
from osbuild.util import containers
from osbuild.util.mnt import MountGuard

CAPABILITIES = ["CAP_MAC_ADMIN", "CAP_NET_ADMIN", "CAP_SYS_PTRACE", "CAP_BPF"]

SCHEMA_2 = """
"options": {
},
"inputs": {
  "type": "object",
  "additionalProperties": false,
  "required": ["images"],
  "properties": {
    "images": {
      "type": "object",
      "description": "Container Image to deploy",
      "additionalProperties": true
    }
  }
},
"devices": {
  "type": "object",
  "additionalProperties": true
},
"mounts": {
  "type": "array"
}
"""


def make_fs_identifier(desc):
    for key in ["uuid", "label"]:
        val = desc.get(key)
        if val:
            return f"{key.upper()}={val}"
    raise ValueError("unknown rootfs type")


def networkless():
    subprocess.run(["podman", "network", "create", "networkless"],
                   encoding="utf8",
                   stdout=sys.stderr,
                   check=True)
    os.makedirs("/etc/cni/net.d/", exist_ok=True)
    with open("/etc/cni/net.d/networkless.conflist", "w", encoding="utf-8") as netfile:
        data = {
           "cniVersion": "0.4.0",
           "name": "networkless",
           "plugins": [
            {
              "type": "loopback"
            }
           ]
        }
        json.dump(data, netfile)


def ostree_container_deploy(tree, inputs, osname, target_imgref, kopts):
    images = containers.parse_containers_input(inputs)
    # networkless()
    for image in images.values():
        with containers.container_source(image) as (_, image_source):
            args = ["podman", "run", "--env=RUST_LOG=debug", "--rm", "--privileged", "--pid=host", "-v", "/:/target",
                    "--security-opt", "label=type:unconfined_t", image_source, "bootc", "install-to-filesystem",
                    "--target-no-signature-verification", "--karg=console=ttyS0,115200n8", "/target"]
            args = ["podman", "--log-level=info", "run", "--pid=host", "--network=none", "--privileged", "--rm",
                    "--security-opt", "label=type:unconfined_t", image_source,
                    "uname", "-a"]
            print(" ".join(args), file=sys.stderr)
            subprocess.run(args,
                           encoding="utf8",
                           stdout=sys.stderr,
                           check=True)


def main(tree, inputs, options):
    osname = options["osname"]
    rootfs = options.get("rootfs")
    mounts = options.get("mounts", [])
    kopts = options.get("kernel_opts", [])
    target_imgref = options.get("target_imgref")

    # schema should catch the case in which there are more
    # than one input but this adds a second layer of security
    if len(inputs) > 1:
        raise ValueError("Only one input accepted")

    if rootfs:
        rootfs_id = make_fs_identifier(rootfs)
        kopts += [f"root={rootfs_id}"]

    with MountGuard() as mounter:
        for mount in mounts:
            path = mount.lstrip("/")
            path = os.path.join(tree, path)
            mounter.mount(path, path)

        ostree_container_deploy(tree, inputs, osname, target_imgref, kopts)


if __name__ == '__main__':
    stage_args = osbuild.api.arguments()
    r = main(stage_args["tree"],
             stage_args["inputs"],
             stage_args["options"])
    sys.exit(r)
